`timescale 1ns / 1ps
class transaction;
  rand bit d;   
  bit q;       
    function transaction copy();
    copy = new();   
    copy.d = this.d; 
    copy.q = this.q; 
  endfunction
    function void display(input string str);
    $display("[%0s] : DIN : %0b DOUT : %0b", str, d, q); 
  endfunction 
endclass
 
class generator;
  transaction trans; 
  mailbox #(transaction) mbx;      
  mailbox #(transaction) mbxref;  
  event sconext; 
  event done;    
  int count;     
   function new(mailbox #(transaction) mbx, mailbox #(transaction) mbxref);
    this.mbx = mbx; 
    this.mbxref = mbxref; 
    trans = new();
  endfunction
    task run();
    repeat(count) begin
      assert(trans.randomize);
      mbx.put(trans.copy); 
      mbxref.put(trans.copy); 
      trans.display("GEN"); 
      @(sconext); 
    end
    ->done; 
  endtask
  endclass

class driver;
  transaction trans; 
  mailbox #(transaction) mbx;
  virtual d_ff_if vif; 
    function new(mailbox #(transaction) mbx);
    this.mbx = mbx;
  endfunction
    task reset();
    vif.reset <= 1'b1; 
    repeat(5) @(posedge vif.clk);
    vif.reset <= 1'b0; 
    @(posedge vif.clk); 
    $display("[DRV] : RESET DONE"); 
  endtask
    task run();
    forever begin
      mbx.get(trans); 
      vif.d <= trans.d; 
      @(posedge vif.clk); 
      trans.display("DRV"); 
      vif.d <= 1'b0; 
      @(posedge vif.clk);
    end
  endtask  
endclass

class monitor;
  transaction trans; 
  mailbox #(transaction) mbx; 
  virtual d_ff_if vif; 
    function new(mailbox #(transaction) mbx);
    this.mbx = mbx; 
  endfunction
    task run();
    trans = new(); 
    forever begin
      repeat(2) @(posedge vif.clk); 
      trans.q = vif.q; 
      mbx.put(trans);
      trans.display("MON"); 
    end
  endtask
  endclass

class scoreboard;
  transaction trans; 
  transaction trref; 
  mailbox #(transaction) mbx; 
  mailbox #(transaction) mbxref;
  event sconext; 
   function new(mailbox #(transaction) mbx, mailbox #(transaction) mbxref);
    this.mbx = mbx; 
    this.mbxref = mbxref; 
  endfunction
    task run();
    forever begin
      mbx.get(trans); 
      mbxref.get(trref); 
      trans.display("SCO"); 
      trref.display("REF"); 
      if (trans.q == trref.d)
        $display("[SCO] : DATA MATCHED"); 
      else
        $display("[SCO] : DATA MISMATCHED");
      ->sconext; 
    end
  endtask
 endclass
 
class environment;
  generator gen; 
  driver drv; 
  monitor mon; 
  scoreboard sco; 
  event next; 
  mailbox #(transaction) gdmbx; 
  mailbox #(transaction) msmbx; 
  mailbox #(transaction) mbxref; 
    virtual d_ff_if vif; 
   function new(virtual d_ff_if vif);
    gdmbx = new(); 
    mbxref = new(); 
    gen = new(gdmbx, mbxref); 
    drv = new(gdmbx); 
    msmbx = new();
    mon = new(msmbx); 
    sco = new(msmbx, mbxref); 
    this.vif = vif; 
    drv.vif = this.vif; 
    mon.vif = this.vif; 
    gen.sconext = next; 
    sco.sconext = next;
  endfunction
    task pre_test();
    drv.reset(); 
  endtask
   task test();
    fork
      gen.run(); 
      drv.run(); 
      mon.run(); 
      sco.run(); 
    join_any
  endtask
    task post_test();
    wait(gen.done.triggered); 
    $finish(); 
  endtask
    task run();
    pre_test(); 
    test(); 
    post_test(); 
  endtask
endclass
 
module tb;
  d_ff_if vif(); 
   d_ff dut(vif); 
  initial begin
    vif.clk <= 0;
  end
    always #10 vif.clk <= ~vif.clk; 
  environment env; 
  initial begin
    env = new(vif); 
    env.gen.count = 30; 
    env.run(); 
  end
    initial begin
    $dumpfile("dump.vcd"); 
    $dumpvars(1); 
  end
endmodule
